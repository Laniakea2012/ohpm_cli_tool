"use strict";var e=this&&this.__awaiter||function(e,t,n,r){return new(n||(n=Promise))((function(o,s){function i(e){try{l(r.next(e))}catch(e){s(e)}}function a(e){try{l(r.throw(e))}catch(e){s(e)}}function l(e){var t;e.done?o(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,a)}l((r=r.apply(e,t||[])).next())}))},t=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.installModules=void 0;const n=t(require("../../../log")),r=require("../../dependency/tree-builder/AsyncTreeBuilder"),o=require("../../dependency/visitor"),s=require("../../dependency/walker"),i=require("../../locker"),a=require("../../resolve-version/resolveDepVersionConflict"),l=require("../../../config"),c=require("../../dependency/util/deleteUselessHarStoreDir"),u=require("../../../common/GlobalState"),d=require("../../dependency/util"),f=require("../../../tools/ohpa/OhpaType"),g=require("../../../common/Constants"),p=require("../../../tools/posh"),y=require("../../alarm"),h=t(require("path")),m=require("../../install-targets/TargetManager"),v=require("../../install-targets/ProjectBuildProfile"),M=require("../../audit"),T=require("../../overrides"),P=require("../../override-dependency-map/OverrideProjectJsonManager"),O=require("../common/definitions");function S(e){const t=new Set;return e.forEach((e=>{e.flatTree().filter((e=>!e.isRoot)).forEach((e=>{t.add(e.nodeKey)}))})),t.size}exports.installModules=function(t){return e(this,void 0,void 0,(function*(){const C=!!m.TargetManager.getInstance().isTargetMod()||l.config.get(l.types.RESOLVE_CONFLICT),L=(0,y.conflictVersionAlarm)(C);let k=v.projectBuildProfile.getUseOhmurl();k||(k=l.config.get(l.types.ENFORCE_DEPENDENCY_KEY));const D=(0,y.dependencyNameInconsistencyAlarm)(k),q=yield function(t,o,s){return e(this,void 0,void 0,(function*(){const c=[];let u=[];const d=Date.now();n.default.debug("TreeBuilding","building dependency trees.");const f=!!m.TargetManager.getInstance().isTargetMod()||l.config.get(l.types.RESOLVE_CONFLICT);for(const[e,n]of t){const t=new r.AsyncTreeBuilder({resolveConflict:f});c.push(t.build(e,n).then((()=>{u.push(t.getResult())})))}return yield Promise.all(c),u.forEach((e=>{o.recordConflictMessage(e),s.recordInconsistencyMessage(e)})),f&&(u=yield function(t){return e(this,void 0,void 0,(function*(){i.PackageLockerManager.getInstance().clearLockerCache();const e=[],n=[];for(const r of t)n.push((0,a.resolveDepVersionConflict)(r).then((t=>{e.push(t)})));return yield Promise.all(n),e}))}(u)),n.default.debug("TreeBuilding",`all dependency trees are built successfully, cost: ${Date.now()-d}ms.`),u}))}(t,L,D);return D.alarmInconsistencyMessage(),yield function(t){return e(this,void 0,void 0,(function*(){const e=Date.now();n.default.debug("TreeInstall","installing dependency trees.");const r=o.DepNodeInstaller.getInstance(),i=[];for(const e of t)i.push(r.run(new s.AsyncFlattenTreeWalker(e)));yield Promise.all(i),n.default.debug("TreeInstall",`all dependency trees are installed successfully, cost: ${Date.now()-e}ms.`),u.GlobalState.installMode.includes(u.ExperimentalOption.INSTALL_ALL)&&(yield(0,c.deleteUselessHarStoreDir)(l.config.getProjectRoot()))}))}(q),yield function(t){return e(this,void 0,void 0,(function*(){const r=Date.now();n.default.debug("TreeSymlink","Symlinking dependency trees");const a=o.DepNodeSymlinker.getInstance(),c=[];for(const e of t)c.push(a.run(new s.AsyncFlattenTreeWalker(e)));yield Promise.all(c),yield function(){return e(this,void 0,void 0,(function*(){const e=i.PackageLockerManager.getInstance();yield(0,d.deleteUselessLinks)(h.default.join(l.config.getProjectRoot(),g.Constants.MyModules,g.Constants.PmDir,g.Constants.MyModules),(t=>!!e.getMaxVersionData(t)))}))}(),n.default.debug("TreeSymlink",`all dependency trees are symlinked successfully, cost ${Date.now()-r}ms`)}))}(q),L.alarmConflictMessage(),function(e){const t=e.filter((e=>e.moduleRootDir===l.config.getProjectRoot()))[0];if(!t)return;const r=t.root,o=[];for(const e of Object.keys(r.rawRequirements)){const n=r.rawRequirements[e];(0,d.parseDependency)(`${e}@${n.spec}`,t.moduleRootDir).type===f.OhpaType.SourceCode&&o.push(`${e}@${n.spec}`)}o.length>0&&n.default.log("warn",p.posh.bold.bgBlack.yellowBright(`Source code dependencies in project-level "${g.Constants.MyPackageJson}" are as follows, which could lead to circular dependencies reference.`)+p.posh.yellow(`\n\t - "${o.join('",\n\t - "')}"\n`))}(q),function(e,t,n){const r={packageNum:S(n),useTargetPath:m.TargetManager.getInstance().isTargetMod(),useInstallAll:!!u.GlobalState.installMode.find((e=>e===u.ExperimentalOption.INSTALL_ALL)),useResolveConflict:e,useParameterFile:!!l.config.getParameterFilePath(),useOverrides:T.overridesMap.size>0,useOverrideDepMap:P.OverrideProjectJsonManager.getInstance().getMapSize()>0,useStrictSsl:l.config.get(l.types.STRICT_SSL),useOdmR2ProjectRoot:l.config.get(l.types.ODM_R2_PROJECT_ROOT),useCrossProcessLock:l.config.get(l.types.ENABLE_CROSS_PROCESS_LOCK),useEnforceDepKey:t,useLockfileStableOrder:l.config.get(l.types.LOCKFILE_STABLE_ORDER)},o=M.auditParamsManager.get().useNoLink;r.useNoLink=void 0===o?!O.defaultInstallOptions.link:o,M.auditParamsManager.add(r)}(C,k,q),q}))};