"use strict";var e=this&&this.__awaiter||function(e,t,s,i){return new(s||(s=Promise))((function(r,a){function o(e){try{n(i.next(e))}catch(e){a(e)}}function c(e){try{n(i.throw(e))}catch(e){a(e)}}function n(e){var t;e.done?r(e.value):(t=e.value,t instanceof s?t:new s((function(e){e(t)}))).then(o,c)}n((i=i.apply(e,t||[])).next())}))},t=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.PackageLockerManager=void 0;const s=require("../dependency/dep-builder/DepBuilderFactory"),i=require("../dependency/util"),r=require("../../util"),a=require("./PackageLocker"),o=require("./index"),c=require("../registry/registry"),n=require("../../util/FsUtil"),l=t(require("path")),d=t(require("semver")),h=t(require("../../log")),p=require("../install/service/handleCliInput"),u=require("../override-dependency-map/OverrideDepMapManager"),g=require("../../common/message"),k=require("../dependency/util/depNodeVersionCompare"),f=require("../../tools/json5"),v=require("../../config"),m=require("../../common/Constants"),L=t(require("os"));class y{static getInstance(){return this.Instance||(this.Instance=new y),this.Instance}syncLoadLockers(e){e.forEach((e=>{this.getModuleLocker(e)}))}constructor(){this.SUFFIX_CONTENT_HASH="#SHA256",this.moduleLockers=new Map,this.deDupeCache=new Map,this.localDepCache=new Map,this.maxVersionCache=new Map,this.nodeDataPromiseCache=new Map,this.versionsMap=new Map,this.projectLockJson=f.JSON5.parse(f.JSON5.stringify(o.LockFile.defaultLockJson));const e=l.default.resolve(L.default.homedir(),m.Constants.PmDir),t=r.HashUtil.getDigest(v.config.getProjectRoot());this.mtimeCacheFilePath=l.default.resolve(e,m.Constants.MtimeCacheDir,t),r.FsBlockingUtil.existsSync(this.mtimeCacheFilePath)?this.readLocalArtifactMtimeCache=r.FsBlockingUtil.readJSON5Sync(this.mtimeCacheFilePath):this.readLocalArtifactMtimeCache={},this.writeLocalArtifactMtimeCache=Object.assign({},this.readLocalArtifactMtimeCache)}getDepNodeData(t){return e(this,void 0,void 0,(function*(){const e=this.getModuleLocker(t.rootDir),s=(0,i.parseDependency)(t.pkg,t.where),r=this.getDedupeKey(s.getName(),s.getFetchSpec());let a=this.tryGetNodeDataFromCache(r,e);return a||(a=yield this.buildNodeDataAsync(t,r)),this.saveInTargetLockFile(a,t.rootDir,s,e),a}))}updateGlobalMtimeCacheAfterInstallation(e,t){this.readLocalArtifactMtimeCache[e]=t,this.updateLocalArtifactMtime(e,t)}updateGlobalHashCache(e,t){this.readLocalArtifactMtimeCache[e.concat(this.SUFFIX_CONTENT_HASH)]=t,this.updateLocalArtifactHash(e,t)}tryGetNodeDataFromCache(e,t){let s=t.getDepNodeDataFromCache(e);return s||(s=this.deDupeCache.get(e)||this.localDepCache.get(e)),s}buildNodeDataAsync(t,i){return e(this,void 0,void 0,(function*(){let e=this.nodeDataPromiseCache.get(i);if(e)h.default.debug("PackageLockerManager",`nodeData ${i} building promise found`);else{h.default.debug("PackageLockerManager",`start building nodeData ${i}.`);e=s.DepBuilderFactory.getInstance().getBuilder(t.pkg,t.builderType,t.where).build(t),this.nodeDataPromiseCache.set(i,e)}const r=yield e;return r.unmet?(this.nodeDataPromiseCache.delete(i),r):(r.isNativeSoType||(this.updateMaxVersion(r),this.collectDepVersions(r)),this.deDupeCache.set(i,r),r.registryType===c.RegistryType.local&&this.localDepCache.set(i,r),r)}))}saveInTargetLockFile(e,t,s,r){const a=this.getDedupeKey(s.getName(),s.getFetchSpec());if(!e.unmet){this.applySpecChangedIfNeeded(e,t,s,a),r.addDepNodeData(a,e);const o=e.pinnedSpec;this.updateLockSpec(t,e.name,this.getVersionByRegistryType(e),o),this.updateLockPkg(t,e.name,o,(0,i.getLockPkgFromNodeData)(e))}}applySpecChangedIfNeeded(e,t,s,r){s.getRawSpec()||(0,i.isLocalDependency)(e.pinnedSpec)||!p.cliInputNames.includes(e.name)||(this.deleteSpecifier(t,r),e.saveSpec=`^${e.pinnedSpec}`)}getDedupeKey(e,t){return`${e}@${t}`}getVersionByRegistryType(e){return e.registryType===c.RegistryType.local?e.fetchSpec:e.saveSpec}getModuleLocker(e){if(!this.moduleLockers.get(e)){const t=this.createPkgLocker(e);this.moduleLockers.set(e,t)}return this.moduleLockers.get(e)}flushAllLockers(){return e(this,void 0,void 0,(function*(){const e=[];this.moduleLockers.forEach((t=>{e.push(t.flush())})),yield Promise.all(e),((yield n.FsUtil.exists(this.mtimeCacheFilePath))||Object.keys(this.writeLocalArtifactMtimeCache).length>0)&&(yield n.FsUtil.createDirIfNotExists(l.default.dirname(this.mtimeCacheFilePath)),yield n.FsUtil.writeFile(this.mtimeCacheFilePath,JSON.stringify(this.writeLocalArtifactMtimeCache,null,2)))}))}createPkgLocker(e){const t=new a.PackageLocker(e);if(r.FsBlockingUtil.existsSync(t.lockFilePath)){const e=r.FsBlockingUtil.readJSON5Sync(t.lockFilePath);o.LockFile.version===e.lockfileVersion&&(this.mergeLockJson(t,e),t.lockJson.lockfileVersion=o.LockFile.defaultLockJson.lockfileVersion,t.lockJson.ATTENTION=o.LockFile.defaultLockJson.ATTENTION)}return t}mergeLockJson(e,t){if(!e.lockJson.specifiers&&!e.lockJson.packages)return void(e.lockJson=t);const s=t.specifiers;e.lockJson.specifiers&&Object.keys(e.lockJson.specifiers).forEach((t=>{s[t]=e.lockJson.specifiers[t]}));const i=t.packages;e.lockJson.packages&&Object.keys(e.lockJson.packages).forEach((t=>{i[t]=e.lockJson.packages[t]})),!t.meta&&t.specifiers&&t.packages&&(t.meta={stableOrder:!1}),e.lockJson.meta.stableOrder=!!t.meta&&t.meta.stableOrder,e.lockJson.specifiers=s,e.lockJson.packages=i}parseSpecKey(e){let t,s,i=e,r=e;if(e.startsWith("@")&&e.includes("/")){const s=e.indexOf("/");t=e.substring(0,s),r=i.substring(s+1,i.length)}const a=r.indexOf("@");if(!(a>0))throw new Error((0,g.format)(g.Messages.Locker.InvalidSpecKey,{specKey:e}));return i=r.substring(0,a),s=r.substring(a+1,r.length),r=i,{scope:t,name:i,pkgName:r,version:s}}getLocalArtifactMtime(e){return this.readLocalArtifactMtimeCache[e]}getLocalArtifactHash(e){return this.readLocalArtifactMtimeCache[e.concat(this.SUFFIX_CONTENT_HASH)]}updateLocalArtifactMtime(e,t){this.writeLocalArtifactMtimeCache[e]=t}updateLocalArtifactHash(e,t){this.writeLocalArtifactMtimeCache[e.concat(this.SUFFIX_CONTENT_HASH)]=t}relativeSpec(e,t){return(0,i.isLocalDependency)(t)?(t.startsWith("file:")&&(t=t.substring(5)),l.default.isAbsolute(t)?n.FsUtil.slash(l.default.relative(e,t)):n.FsUtil.slash(t)):t}relativeLockPkg(e,t){return t?(t.resolved&&(0,i.isLocalDependency)(t.resolved)&&(t.resolved=this.relativeSpec(e,t.resolved)),t.resolved_hsp&&(0,i.isLocalDependency)(t.resolved_hsp)&&(t.resolved_hsp=this.relativeSpec(e,t.resolved_hsp)),t):t}resolveLockPkg(e,t){return t?(t.resolved&&(0,i.isLocalDependency)(t.resolved)&&(t.resolved=l.default.resolve(e,t.resolved)),t.resolved_hsp&&(0,i.isLocalDependency)(t.resolved_hsp)&&(t.resolved_hsp=l.default.resolve(e,t.resolved_hsp)),t):t}resolveLockSpec(e,t){if(!t)return t;const s=this.parseSpecKey(t);if(s.version&&(0,i.isLocalDependency)(s.version)){const i=l.default.resolve(e,s.version);return t=`${s.name}@${i}`}return t}getLockSpec(e,t,s){const i=this.relativeSpec(e,s),r=this.getModuleLocker(e),a=`${t}@${s}`,o=this.projectLockJson.specifiers;let c=r.getLockSpec(t,i);if(!c&&o&&(c=o[a],c)){const i=this.parseSpecKey(c);r.updateLockSpec(t,s,this.relativeSpec(e,i.version))}return this.resolveLockSpec(e,c)}updateLockSpec(e,t,s,i){const r=this.relativeSpec(e,s),a=this.relativeSpec(e,i),o=`${t}@${s}`,c=this.getModuleLocker(e),n=this.projectLockJson.specifiers;c.updateLockSpec(t,r,a),n[o]=`${t}@${i}`}getLockPkg(e,t,s){const i=this.relativeSpec(e,s),r=this.getLockSpec(e,t,s),a=this.projectLockJson.packages,o=this.getModuleLocker(e);let c=o.getLockPkg(t,i);return c||(c=this.relativeLockPkg(e,a[r]),r&&c&&o.updateLockPkg(t,i,c)),this.resolveLockPkg(e,c)}updateLockPkg(e,t,s,i){const r=Object.assign({},i),a=this.getModuleLocker(e),o=this.relativeSpec(e,s),c=this.relativeLockPkg(e,r);this.addOrRemoveOverrideDependencyMapTag(e,t,o,c),a.updateLockPkg(t,o,c);this.projectLockJson.packages[`${t}@${s}`]=r}addOrRemoveOverrideDependencyMapTag(e,t,s,i){i.registryType!==c.RegistryType.local||l.default.isAbsolute(s)||(s=l.default.resolve(e,s));const r=u.OverrideDepMapManager.getInstance();r.hasConfig()&&r.needOverride(t,s)?i.maskedByOverrideDependencyMap=!0:delete i.maskedByOverrideDependencyMap}clearSpecifiers(e,t){if(t.allModules)for(const e of this.moduleLockers.values())e.clearSpecifiers();else{this.getModuleLocker(e).clearSpecifiers()}}deleteSpecifier(e,t){const s=this.getModuleLocker(e),i=this.parseSpecKey(t);if(i.version&&l.default.isAbsolute(i.version)){const s=n.FsUtil.slash(l.default.relative(e,i.version));t=`${i.name}@${s}`}s.deleteSpecifier(t)}clearVisitedSet(e){this.getModuleLocker(e).clearVisitedSet()}deletePackage(e,t){const s=this.parseSpecKey(t);if(s.version&&l.default.isAbsolute(s.version)){const i=n.FsUtil.slash(l.default.relative(e,s.version));t=`${s.name}@${i}`}this.getModuleLocker(e).deletePackage(t)}clearLockerCache(){this.deDupeCache.clear(),this.nodeDataPromiseCache.clear(),this.versionsMap.clear(),this.localDepCache.clear(),this.projectLockJson.packages={},this.projectLockJson.specifiers={},this.moduleLockers.forEach((e=>{e.dedupeCache.clear()}))}getVersionSet(e){var t;return null!==(t=this.versionsMap.get(e))&&void 0!==t?t:new Set}collectDepVersions(e){e.isNativeSoType||(this.versionsMap.has(e.name)||this.versionsMap.set(e.name,new Set),this.versionsMap.get(e.name).add(e.pinnedSpec))}getMaxVersionData(e){return this.maxVersionCache.get(e)}updateMaxVersion(e){this.isMaxVersion(e)&&this.maxVersionCache.set(e.name,e)}isMaxVersion(e){if(e.isRoot)return!0;if(e.isNativeSoType)return!1;if(!(0,i.isLocalDependency)(e.pinnedSpec)&&!d.default.valid(e.pinnedSpec)||!d.default.valid(e.version))throw new Error((0,g.format)(g.Messages.DepBuilder.InvalidDepVersion,{version:e.version,depKey:`${e.name}@${e.pinnedSpec}`}));const t=this.maxVersionCache.get(e.name);return!t||(0,k.depNodeVersionCompare)(e,t)>0}}exports.PackageLockerManager=y;