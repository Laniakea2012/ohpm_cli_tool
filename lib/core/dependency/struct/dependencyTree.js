"use strict";var e=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.DependencyTree=void 0;const t=e(require("semver")),o=require("../util"),i=require("../../overrides"),r=require("../../../tools/ohpa/OhpaType"),s=require("../../../common/message"),n=require("../util/depNodeVersionCompare");exports.DependencyTree=class{constructor(e,t,o){this.versionsMap=new Map,this._finalDepNodeCache=new Map,this._nativeSoTypeNodeCache=new Map,this._roughDepCache=new Map,this._root=t,this._moduleRootDir=e,this._isResolveConflict=!!o}get root(){return this._root}get moduleRootDir(){return this._moduleRootDir}get finalDepList(){return Array.from(this._finalDepNodeCache.values())}get roughDepList(){const e=Array.from(this._roughDepCache.values()),t=[];return e.forEach((e=>{t.push(...Object.values(e))})),t}flatTree(){return this._isResolveConflict?[...this.finalDepList,...this._nativeSoTypeNodeCache.values()]:this.roughDepList}registerNode(e){this.addNode(e),e.isNativeSoType||(this.updateMaxVersionMap(e.name,e),this.collectPkgVersions(e.name,e.pinnedSpec))}findNode(e,t){const o=this._roughDepCache.get(e);if(o)return o[t]}whereToFindChildNode(e,t){return(0,o.isLocalDependency)(e)?t.isLink||t.ohpaType!==r.OhpaType.SourceCode?t.resolvePkgStoreDir(this.moduleRootDir):t.fetchSpec:t.resolveSaveRootDir(this.moduleRootDir)}pickNode(e,t,r){t=(0,i.resolveSpecWithOverrides)(this.moduleRootDir,e,r.requirements);const n=this.whereToFindChildNode(t,r),a=(0,o.parseDependency)(`${e}@${t}`,n);let h;if(this._nativeSoTypeNodeCache.has(a.getFetchSpec())&&(h=this._nativeSoTypeNodeCache.get(a.getFetchSpec())),!h&&this._isResolveConflict)h=this._finalDepNodeCache.get(e);else if(!h){const t=this._roughDepCache.get(e);t&&(h=t[a.getFetchSpec()])}if(!h)throw new Error((0,s.format)(s.Messages.Common.DepNodeNotFound,{name:e,fetchSpec:t}));return h}pickMaxVersion(e){const t=this._finalDepNodeCache.get(e);if(!t)throw new Error((0,s.format)(s.Messages.Common.DepNodeMaxVersionNotFound,{name:e}));return t}pickRoughNode(e,t,r){t=(0,i.resolveSpecWithOverrides)(this.moduleRootDir,e,r.requirements);const n=this.whereToFindChildNode(t,r),a=(0,o.parseDependency)(`${e}@${t}`,n),h=this._roughDepCache.get(e);if(h)return h[a.getFetchSpec()];throw new Error((0,s.format)(s.Messages.Common.RoughDepNodeNotFound,{name:e,fetchSpec:t}))}updateMaxVersionMap(e,t){this.isMaxVersion(t)&&this._finalDepNodeCache.set(e,t)}isMaxVersion(e){if(e.isRoot)return!0;if(e.isNativeSoType)return!1;const i=this._finalDepNodeCache.get(e.name);if(!i||i.unmet)return!0;if(e.unmet)return!1;if(!(0,o.isLocalDependency)(e.pinnedSpec)&&!t.default.valid(e.pinnedSpec)||!t.default.valid(e.version))throw new Error((0,s.format)(s.Messages.DepBuilder.InvalidDepVersion,{version:e.version,depKey:`${e.name}@${e.pinnedSpec}`}));return(0,n.depNodeVersionCompare)(e.nodeData,i.nodeData)>0}getVersionSet(e){return this.versionsMap.get(e)}collectPkgVersions(e,t){this.versionsMap.has(e)||this.versionsMap.set(e,new Set),this.versionsMap.get(e).add(t)}addNode(e){let t=this._roughDepCache.get(e.name);t?t[e.fetchSpec]=e:(t={[e.fetchSpec]:e},this._roughDepCache.set(e.name,t)),e.isNativeSoType&&this._nativeSoTypeNodeCache.set(e.fetchSpec,e)}};